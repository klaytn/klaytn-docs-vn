# 7-2. Thành phần UploadPhoto

![tải lên ảnh](../../../../bapp/tutorials/klaystagram/images/klaystagram-uploadphoto.png)

1. Vai trò của thành phần `UploadPhoto`
2. Mã thành phần
3. Tương tác với hợp đồng
4. Cập nhật dữ liệu vào cửa hàng: hàm `updateFeed`

## 1) Chức năng của thành phần `UploadPhoto` <a href="#1-uploadphoto-component-s-role" id="1-uploadphoto-component-s-role"></a>

Thành phần `UploadPhoto` xử lý yêu cầu tải ảnh lên blockchain Klaytn. Quy trình như sau:

1. Gọi phương thức `uploadPhoto` của hợp đồng thông minh bằng cách gửi một giao dịch. Trong phương thức hợp đồng `uploadPhoto`, một token ERC-721 mới được đúc.
2. Sau khi gửi một giao dịch, thể hiện tiến trình cùng vòng đời giao dịch bằng thành phần `Toast`.
3. Khi giao dịch tiến vào một khối, cập nhật `PhotoData` mới trong cửa hàng redux cục bộ.

**Limiting content size**\
Kích thước tối đa của một giao dịch là `32KB`. Vậy nên chúng tôi hạn chế kích thước của dữ liệu đầu vào (ảnh và mô tả) không vượt quá `30KB` để gửi đi an toàn.

* Quy mô dữ liệu chuỗi được giới hạn ở `2KB`
* Ảnh được nén để có kích thước nhỏ hơn `28KB` bằng hàm [`imageCompression()`](https://github.com/klaytn/klaystagram/blob/main/src/utils/imageCompression.js).

## 2) Mã thành phần <a href="#2-component-code" id="2-component-code"></a>

```javascript
// src/components/UploadPhoto.js

import React, { Component } from 'react'
import { connect } from 'react-redux'
import imageCompression from 'utils/imageCompression';
import ui from 'utils/ui'
import Input from 'components/Input'
import InputFile from 'components/InputFile'
import Textarea from 'components/Textarea'
import Button from 'components/Button'

import * as photoActions from 'redux/actions/photos'

import './UploadPhoto.scss'

// Đặt giới hạn nội dung
const MAX_IMAGE_SIZE = 30 * 1024 // 30KB
const MAX_IMAGE_SIZE_MB = 30 / 1024 // 30KB

class UploadPhoto extends Component {
  state = {
    file: '',
    fileName: '',
    location: '',
    caption: '',
    warningMessage: '',
    isCompressing: false,
  }

  handleInputChange = (e) => {
    this.setState({
      [e.target.name]: e.target.value,
    })
  }

  handleFileChange = (e) => {
    const file = e.target.files[0]

    /**
     * Nếu kích thước ảnh lớn hơn MAX_IMAGE_SIZE(30KB),
     * Nén ảnh để tải trên giao dịch
     * cf. Kích thước dữ liệu đầu vào giao dịch tối đa: 32KB
     */
    if (file.size > MAX_IMAGE_SIZE) {
      this.setState({
        isCompressing: true,
      })
      return this.compressImage(file)
    }

    return this.setState({
      file,
      fileName: file.name,
    })
  }

  handleSubmit = (e) => {
    e.preventDefault()
    const { file, fileName, location, caption } = this.state
    this.props.uploadPhoto(file, fileName, location, caption)
    ui.hideModal()
  }

  compressImage = async (imageFile) => {
    try {
      const compressedFile = await imageCompression(imageFile, MAX_IMAGE_SIZE_MB)
      this.setState({
        isCompressing: false,
        file: compressedFile,
        fileName: compressedFile.name,
      })
    } catch (error) {
      this.setState({
        isCompressing: false,
        warningMessage: '* Fail to compress image'
      })
    }
  }

  render() {
    const { fileName, location, caption, isCompressing, warningMessage } = this.state
    return (
      <form className="UploadPhoto" onSubmit={this.handleSubmit}>
        <InputFile
          className="UploadPhoto__file"
          name="file"
          label="Search file"
          fileName={isCompressing ? "Đang nén ảnh..." : fileName}
          onChange={this.handleFileChange}
          err={warningMessage}
          accept=".png, .jpg, .jpeg"
          required
        />
        <Input
          className="UploadPhoto__location"
          name="location"
          label="Location"
          value={location}
          onChange={this.handleInputChange}
          placeholder="Bạn đã chụp ảnh này ở đâu?"
          required
        />
        <Textarea
          className="UploadPhoto__caption"
          name="caption"
          value={caption}
          label="Caption"
          onChange={this.handleInputChange}
          placeholder="Upload your memories"
          required
        />
        <Button
          className="UploadPhoto__upload"
          type="submit"
          title="Upload"
        />
      </form>
    )
  }
}

const mapDispatchToProps = (dispatch) => ({
  uploadPhoto: (file, fileName, location, caption) =>
    dispatch(photoActions.uploadPhoto(file, fileName, location, caption)),
})

export default connect(null, mapDispatchToProps)(UploadPhoto)
```

## 3) Tương tác với hợp đồng <a href="#3-interact-with-contract" id="3-interact-with-contract"></a>

Hãy tạo một hàm để viết dữ liệu ảnh lên Klaytn. **Send transaction to contract: `uploadPhoto`**\
Không giống các lệnh gọi hàm Read-only, việc viết dữ liệu làm phát sinh phí giao dịch. Phí giao dịch được xác định bằng lượng `gas` đã sử dụng. `gas` là đơn vị đo thể hiện số lượng phép tính cần để xử lý giao dịch.

Vì những lý do này, việc gửi một giao dịch cần hai thuộc tính `from` và `gas`.

1.  Chuyển đổi tệp ảnh thành một chuỗi byte để tải trên giao dịch

    (Trong [Klaystagram contract](../4.-write-klaystagram-smart-contract.md), ta đã định nghĩa định dạng ảnh là byte trong cấu trúc `PhotoData`)

    * Đọc dữ liệu ảnh như một ArrayBuffer bằng `FileReader`
    * Chuyển đổi ArrayBuffer thành chuỗi số hex
    * Add Prefix `0x` to satisfy bytes format
2. Invoke the contract method: `uploadPhoto`
   * `from`: An account that sends this transaction and pays the transaction fee.
   * `gas`: The maximum amount of gas that the `from` account is willing to pay for this transaction.
3. After sending the transaction, show progress along the transaction lifecycle using `Toast` component.
4. If the transaction successfully gets into a block, call `updateFeed` function to add the new photo into the feed page.

```javascript
// src/redux/actions/photo.js

export const uploadPhoto = (
  file,
  fileName,
  location,
  caption
) => (dispatch) => {
  // 1. Convert photo file as a hex string to load on transaction
  const reader = new window.FileReader()
  reader.readAsArrayBuffer(file)
  reader.onloadend = () => {
    const buffer = Buffer.from(reader.result)

    // Add prefix `0x` to hexString to recognize hexString as bytes by contract
    const hexString = "0x" + buffer.toString('hex')

    // 2. Invoke the contract method: uploadPhoto
    // Send transaction with photo file(hexString) and descriptions
    try{
      KlaystagramContract.methods.uploadPhoto(hexString, fileName, location, caption).send({
        from: getWallet().address,
        gas: '200000000',
      }, (error, txHash) => {
        if (error) throw error;

        // 3. After sending the transaction,
        // show progress along the transaction lifecycle using `Toast` component.
        ui.showToast({
          status: 'pending',
          message: `Sending a transaction... (uploadPhoto)`,
          txHash,
        })
      })
        .then((receipt) => {
          ui.showToast({
            status: receipt.status ? 'success' : 'fail',
            message: `Received receipt! It means your transaction is
            in klaytn block (#${receipt.blockNumber}) (uploadPhoto)`,
            link: receipt.transactionHash,
          })

          // 4. If the transaction successfully gets into a block,
          // call `updateFeed` function to add the new photo into the feed page.
          if(receipt.status) {
            const tokenId = receipt.events.PhotoUploaded.returnValues[0]
            dispatch(updateFeed(tokenId))
          }
        })
    } catch (error) {
      ui.showToast({
        status: 'error',
        message: error.toString(),
      })
    }
  }
}
```

**cf) Transaction life cycle**

After sending transaction, you can get transaction life cycle (`transactionHash`, `receipt`, `error`).

* `transactionHash` event is fired once your signed transaction instance is properly constructed. You can get the transaction hash before sending the transaction over the network.
* `receipt` event is fired when you get a transaction receipt. It means your transaction is included in a block. You can check the block number by `receipt.blockNumber`.
* `error` event is fired when something goes wrong.

## 4. Update photo in the feed page: `updateFeed` <a href="#4-update-photo-in-the-feed-page-updatefeed" id="4-update-photo-in-the-feed-page-updatefeed"></a>

After successfully sending the transaction to the contract, FeedPage needs to be updated.\
In order to update the photo feed, we need to get the new photo data we've just uploaded. Let's call `getPhoto()` with `tokenId`. `tokenId` can be retrieved from the transaction receipt. Then add the new photo data in the local redux store.

```javascript
// src/redux/actions/photo.js

/**
 * 1. Call contract method: getPhoto()
 * To get new photo data we've just uploaded,
 * call `getPhoto()` with tokenId from receipt after sending transaction
*/
const updateFeed = (tokenId) => (dispatch, getState) => {
  KlaystagramContract.methods.getPhoto(tokenId).call()
    .then((newPhoto) => {
      const { photos: { feed } } = getState()
      const newFeed = [feedParser(newPhoto), ...feed]

      // 2. update new feed to store
      dispatch(setFeed(newFeed))
    })
}
```
